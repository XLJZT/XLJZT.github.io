---
title: LeetCode 位运算
description: leetcode刷题
date: 2023-3-8
top_image: https://gitlab.com/XLJZT/img/-/raw/main/blog/pictures/2023/03/8_9_53_7_image-20230308095303525.png
cover: https://gitlab.com/XLJZT/img/-/raw/main/blog/pictures/2023/03/8_9_53_7_image-20230308095303525.png
categories: 
- Leetcode
tag: 
- Leetcode
- 算法
- c++

---

# 位运算

位运算符是一种用于操作二进制数的运算符，它们对二进制数的每一位进行操作。以下是常见的位运算符：

1. 按位与（&）：将两个数的每一位进行与运算，如果两个位都为1，则结果为1，否则为0。
2. 按位或（|）：将两个数的每一位进行或运算，如果两个位都为0，则结果为0，否则为1。
3. 按位异或（^）：将两个数的每一位进行异或运算，如果两个位相同，则结果为0，否则为1。
4. 按位取反（~）：将一个数的每一位取反，即0变为1，1变为0。
5. 左移（<<）：将一个数的二进制位向左移动指定的位数，右边补0。
6. 右移（>>）：将一个数的二进制位向右移动指定的位数，左边补0或者补符号位。

位运算符常用于系统编程、嵌入式系统等领域，可以用来进行位操作，如数据压缩、加密解密、图像处理等。

# 只出现一次的数字

> https://leetcode.cn/problems/single-number/

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

**示例 1 ：**

```
输入：nums = [2,2,1]
输出：1
```

**示例 2 ：**

```
输入：nums = [4,1,2,1,2]
输出：4
```

**示例 3 ：**

```
输入：nums = [1]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`
- 除了某个元素只出现一次以外，其余每个元素均出现两次。

**解题：位运算**

仔细阅读题目可知，在数组中仅有一个元素且仅出现一次，其余元素均为两次。由此我们可以想到异或运算

- 任何数和 000 做异或运算，结果仍然是原来的数，即 a⊕0=a
- 任何数和其自身做异或运算，结果是 000，即 a⊕a=0
- 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int e : nums){
            res ^= e;
            
        }
        return res;
    }
};
```

# 比特位计数

> https://leetcode.cn/problems/counting-bits/description/

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

**示例 2：**

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

 

**提示：**

- `0 <= n <= 10^5`

**解题：位运算**

利用 Brian Kernighan 算法，可以在一定程度上进一步提升计算速度。Brian Kernighan 算法的原理是：对于任意整数 x，令 x=x & (x−1)，该运算将 x 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」。

使用类似递归的思想对此算法进行一个改进，通过保存 x 之前的值并且加一为当前 x 二进制表示下 1 的个数

> 8 	-> 1000
>
> 7     -> 0111
>
> 8&7-> 0000 = 0

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> bits(n+1);
        bits[0] = 0;
        for(int i = 1; i <= n; i++){
            bits[i] = bits[i&(i-1)]+1;
        }
        return bits;
    }
};
```

# 汉明距离

> https://leetcode.cn/problems/hamming-distance/description/

两个整数之间的 [汉明距离](https://baike.baidu.com/item/汉明距离) 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

**示例 1：**

```
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
```

**示例 2：**

```
输入：x = 3, y = 1
输出：1
```

**提示：**

- `0 <= x, y <= 231 - 1`

**解题：位运算 +  计数**

汉明距离统计的为两个数字之间不同位置的数目，通过异或运算，相同的为 0，不同的为 1，然后统计 1 的个数即为两个数字之间不同位置的数目。

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int z = x^y;
        int res = 0;
        while(z > 0){
            z &= z-1;
            res++;
        }
        return res;
    }
};
```

